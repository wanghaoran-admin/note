### 封装、继承、多态

**封装、继承、多态** 是面向对象编程（OOP）的三大核心特性。

**封装（Encapsulation）**

- **概念**：将数据和方法封装在类中，对外界隐藏内部实现细节，只暴露必要的接口（如公共方法）来操作数据。



**继承（Inheritance）**

- **概念**：一个类可以继承另一个类的属性和方法，子类可以重用父类的代码，还能扩展新的功能。

  

**多态（Polymorphism）**

- **概念**：同一个方法在不同对象上表现出不同的行为，分为 **编译时多态**（方法重载）和 **运行时多态**（方法重写）。







### JDK、JRE 、JVM区别

**JDK > JRE > JVM**：

1. **JVM** 是最核心的部分，负责运行 Java 程序。
2. **JRE** 包含 JVM 和运行时库，提供 Java 程序的运行环境。
3. **JDK** 包含 JRE 和开发工具，是开发 Java 程序的完整工具包。









### JVM 内存模型

```
+---------------- JVM 内存模型 ----------------+
|                                            |
|  +------------------+  +---------------+   |
|  |      堆          |  |  元空间(Metaspace)| <-- 方法区的实现
|  |  (Heap)          |  |               |   |
|  |  - 对象实例       |  |  - 类元数据   |   |
|  |  - 静态变量       |  |  - 方法字节码 |   |
|  |  - 常量池         |  |               |   |
|  +------------------+  +---------------+   |
|                                            |
|  +------------+  +-------------+  +--------+
|  | 程序计数器 |  | 本地方法栈  |  | 栈      |
|  +------------+  +-------------+  +--------+
|                                            |
+--------------------------------------------+

```



### ==和equals

==比较的是栈中的值（基本数据类型就存在栈中），如果是引用类型就比较堆的地址

```java
String a = new String("ni");
String b = new String("ni");
String c = b;

int shu1 = 1;
int shu2 = 1;

System.out.println(a == b);  //内存地址不同false
System.out.println(shu1 == shu2); //栈相同true
System.out.println(b == c); //内存地址相同true
```





**示例：**

```java
VmInfoDTO vmInfoDTO1 = new VmInfoDTO();
//vmInfoDTO1.setAddr("cscsv");
VmInfoDTO vmInfoDTO2 = new VmInfoDTO();
System.out.println(vmInfoDTO1.equals(vmInfoDTO2));
```

如果这里重写了equals方法，比较内容【就是字段是否相同，@Data注解】

如果这里没有重写了equals方法，比较地址【就是object类继承下来的，类中equals和==功能一致】





### final关键字

**修饰变量**

- **常量**：当 `final` 用于变量时，表示该变量的值不可更改

**修饰方法**

- **防止方法被重写**：当 `final` 用于方法时，表示该方法不能被子类重写或覆盖。

**修饰类**

- **防止类被继承**：当 `final` 用于类时，表示该类不能被继承。无法创建该类的子类。







### String、StringBuffer、StringBuilder区别及使用场景

**String**

**不可变性**：`String` 对象是不可变的 **线程安全**。一旦创建，字符串的内容就不能更改。每次对 `String` 的修改都会创建一个新的 `String` 对象，而不会修改原有的对象。

​	

**StringBuffer**

**线程安全**：`StringBuffer` 的操作是 **线程安全** 的，它的方法是同步的（`synchronized`），这意味着它可以在多线程环境中安全使用。



**StringBuilder**

**线程不安全**：`StringBuilder` 的方法 **不是同步的**，这意味着它不支持多线程环境中的线程安全问题，因此在多线程环境下可能会出现问题。





### 重载和重写的区别

**重载**

同一个类中方法名 参数列表 包括参数的数量、类型、顺序等不同

**重写**

重写是指在子类重写父类中**已经存在**的方法。方法名 参数列表 包括参数的数量、类型、顺序相同





### 接口抽象类区别

| 特性           | **接口（Interface）**                               | **抽象类（Abstract Class）**                   |
| -------------- | --------------------------------------------------- | ---------------------------------------------- |
| **方法实现**   | 接口中的方法默认是抽象的（除非是默认方法）          | 抽象类可以包含抽象方法和已实现的方法           |
| **成员变量**   | 接口中的成员变量默认是 `public static final` 常量   | 抽象类可以有实例变量，并可以有不同的访问修饰符 |
| **继承/实现**  | 一个类可以实现多个接口                              | 一个类只能继承一个抽象类                       |
| **构造方法**   | 接口不能有构造方法                                  | 抽象类可以有构造方法                           |
| **多继承**     | 支持多继承（一个类可以实现多个接口）                | 不支持多继承（只能继承一个抽象类）             |
| **访问修饰符** | 接口中的方法默认是 `public`，不能指定其他访问修饰符 | 抽象类中的方法可以有不同的访问修饰符           |
| **实例化**     | 不能实例化接口                                      | 不能实例化抽象类                               |
| **用途**       | 用于定义行为规范，适用于多个类共享的行为            | 用于定义通用的类，适用于有共性和基本实现的类   |







### List和Set

**`List`**：`List` 是有序的集合，意味着它会保持元素插入的顺序。你可以通过索引访问其中的元素。

**`Set`**：`Set` 是无序的集合，不保证元素的顺序。【只能通过迭代器逐一遍历】







### 为什么重写equals一定要重写hashcode

**没有重写前** `hashCode` 方法返回对象的哈希值，这个哈希值就是在堆中的地址。

**重写后** 我们会根据对象的字段来计算哈希值，这样相同内容的对象（即使是不同的实例）也能产生相同的哈希值。

【**HashSet**、**HashMap**等在内部使用的是哈希值来进行对象存储和查找】







### ArrayList与数组的区别与联系

JDK中使用数组 实现 ArrayList， **数组定长**，

ArrayList 为**不定长**（可以动态扩容）







### HashMap 和 HashTable的区别

Hashtable是**线程安全**的，HashMap**线程不安全**

Hashtable默认的**初始大小为11**，之后每次扩充，容量变为**原来的2n+1**。

HashMap默认的**初始化大小为16**。之后每次扩充，容量变为**原来的2倍**









### ArrayList和LinkedList的区别

**实现：**

ArrayList 基于`动态数组`，连续的内存访问，适合下标访问。`扩容机制`：因为数组长度固定，超出长度需要新建数组

LinkedList 基于`链表`，可以存在在分散的内存中，适合`插入和删除不适合查询`



**特点：**

ArrayList `元素访问的效率高` `插入和删除操作的效率低`

LinkedList 必须使用iterator不能使用for循环，`因为性能消耗极大`









### 为什么ArrayList遍历快

ArrayList 使用 数组 作为元素的存储方式

对于数组而言，在内存中是**一段地址连续**的空间

可以使用**元素地址+偏移量**的方式直接定位目标元素的内存地址。





### 静态变量和实例变量的区别

**静态变量**属于类，当类加载时被初始化， 并且只会实例化一次

**实例变量**属于对象，当对象被创建时初始化，每个对象拥有自己的实例变量。通过对象访问。





### HashMap底层原理

 **使用 `hashCode()` 判断**

当我们调用 `put()` 方法向 `HashMap` 中添加一个元素时，`HashMap` 会先使用该元素的 `hashCode()` 来计算其在哈希表中的存储位置。



**哈希值相同的情况下**

如果计算出的哈希值已经存在，`HashMap` 会检查该位置是否已经存有元素。如果没有元素，直接存入该位置。如果有元素，那么接下来会使用 **`equals()`** 方法进一步比较键是否相等。

- 如果 `equals()` 返回 `true`，那么说明两个对象是相等的，此时会更新旧的值

- 如果 `equals()` 返回 `false`，则表示这个新的键与该位置上的现有键不同，`HashMap` 会采用 **链表**（或红黑树，取决于实现细节）来处理 **哈希冲突**。这就是哈希冲突的解决方法。



**哈希冲突的处理**

**链表**：如果同一个桶中有多个元素，`HashMap` 使用链表来存储这些元素。每个元素都是一个键值对对象，它们通过链表连接起来。

**红黑树（JDK 8 及以上版本）**：当同一个桶中元素数量较多（通常是超过 8 个）时，`HashMap` 会将链表转化为红黑树，以提高查找效率。





### 介绍下多线程

用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。

多线程：指的是这个程序（一个进程）运行时产生了不止一个线程





### 连接池概念

一次性申请多个连接对象，缓存在池中，每次需要使用连接对象时直接从池中获取， 节省了频繁向数据库申请连接的时间。

常用连接池： **dbcp** / **c3p0** / **druid**





### 哈希码相同equals一定相同吗

哈希码相同并不意味着 `equals()` 必须返回 `true`，但如果两个对象的 `equals()` 方法返回 `true`，那么它们的 `hashCode()` 必须相同。【哈希会导致哈希冲突，也就是多个字符用相同哈希值，equals比较的是内存中的数据必然相同】





### ACID是什么

ACID 是数据库事务的四大基本特性，指：

- **原子性（Atomicity）**：事务中的所有操作要么全部成功，要么全部失败，不能只执行部分操作。
- **一致性（Consistency）**：事务的执行会使数据库从一个一致性状态转变到另一个一致性状态。事务执行前后，数据库的完整性约束（如外键约束）必须保持有效。
- **隔离性（Isolation）**：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。事务的隔离级别可以通过设置来控制。
- **持久性（Durability）**：一旦事务提交，其对数据库的修改将永久保存，即使系统发生崩溃，数据也不会丢失。







### 如果实现IOC







### 值传递和引用传递有什么区别

















### 说说cas

**CAS** 是一种常用的无锁并发控制技术，它通过比较并交换值来实现原子操作，能够高效地处理并发更新。

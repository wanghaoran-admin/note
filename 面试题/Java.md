### 1. 封装、继承、多态

**封装、继承、多态** 是面向对象编程（OOP）的三大核心特性。

**封装（Encapsulation）**

- **概念**：将数据和方法封装在类中，对外界隐藏内部实现细节，只暴露必要的接口（如公共方法）来操作数据。



**继承（Inheritance）**

- **概念**：一个类可以继承另一个类的属性和方法，子类可以重用父类的代码，还能扩展新的功能。

  

**多态（Polymorphism）**

- **概念**：同一个方法在不同对象上表现出不同的行为，分为 **编译时多态**（方法重载）和 **运行时多态**（方法重写）。







### 2. JDK、JRE 、JVM区别

**JDK > JRE > JVM**：

1. **JVM** 是最核心的部分，负责运行 Java 程序。
2. **JRE** 包含 JVM 和运行时库，提供 Java 程序的运行环境。
3. **JDK** 包含 JRE 和开发工具，是开发 Java 程序的完整工具包。









### 3. JVM 内存模型

```
+---------------- JVM 内存模型 ----------------+
|                                            |
|  +------------------+  +---------------+   |
|  |      堆          |  |  元空间(Metaspace)| <-- 方法区的实现
|  |  (Heap)          |  |               |   |
|  |  - 对象实例       |  |  - 类元数据   |   |
|  |  - 静态变量       |  |  - 方法字节码 |   |
|  |  - 常量池         |  |               |   |
|  +------------------+  +---------------+   |
|                                            |
|  +------------+  +-------------+  +--------+
|  | 程序计数器 |  | 本地方法栈  |  | 栈      |
|  +------------+  +-------------+  +--------+
|                                            |
+--------------------------------------------+

```



### 4. ==和equals

==比较的是栈中的值（基本数据类型就存在栈中），如果是引用类型就比较堆的地址

```java
String a = new String("ni");
String b = new String("ni");
String c = b;

int shu1 = 1;
int shu2 = 1;

System.out.println(a == b);  //内存地址不同false
System.out.println(shu1 == shu2); //栈相同true
System.out.println(b == c); //内存地址相同true
```





**示例：**

```java
VmInfoDTO vmInfoDTO1 = new VmInfoDTO();
//vmInfoDTO1.setAddr("cscsv");
VmInfoDTO vmInfoDTO2 = new VmInfoDTO();
System.out.println(vmInfoDTO1.equals(vmInfoDTO2));
```

如果这里重写了equals方法，比较内容【就是字段是否相同，@Data注解】

如果这里没有重写了equals方法，比较地址【就是object类继承下来的，类中equals和==功能一致】





### 5. final关键字

**修饰变量**

- **常量**：当 `final` 用于变量时，表示该变量的值不可更改

**修饰方法**

- **防止方法被重写**：当 `final` 用于方法时，表示该方法不能被子类重写或覆盖。

**修饰类**

- **防止类被继承**：当 `final` 用于类时，表示该类不能被继承。无法创建该类的子类。







### 6. String、StringBuffer、StringBuilder区别

**String**

**不可变性**：`String` 对象是不可变的 **线程安全**。一旦创建，字符串的内容就不能更改。每次对 `String` 的修改都会创建一个新的 `String` 对象，而不会修改原有的对象。

​	

**StringBuffer**

**线程安全**：`StringBuffer` 的操作是 **线程安全** 的，它的方法是同步的（`synchronized`），这意味着它可以在多线程环境中安全使用。



**StringBuilder**

**线程不安全**：`StringBuilder` 的方法 **不是同步的**，这意味着它不支持多线程环境中的线程安全问题，因此在多线程环境下可能会出现问题。





### 7. 重载和重写的区别

**重载**

同一个类中方法名 参数列表 包括参数的数量、类型、顺序等不同

**重写**

重写是指在子类重写父类中**已经存在**的方法。方法名 参数列表 包括参数的数量、类型、顺序相同





### 8. 接口抽象类区别

| 特性           | **接口（Interface）**                               | **抽象类（Abstract Class）**                   |
| -------------- | --------------------------------------------------- | ---------------------------------------------- |
| **方法实现**   | 接口中的方法默认是抽象的（除非是默认方法）          | 抽象类可以包含抽象方法和已实现的方法           |
| **成员变量**   | 接口中的成员变量默认是 `public static final` 常量   | 抽象类可以有实例变量，并可以有不同的访问修饰符 |
| **继承/实现**  | 一个类可以实现多个接口                              | 一个类只能继承一个抽象类                       |
| **构造方法**   | 接口不能有构造方法                                  | 抽象类可以有构造方法                           |
| **多继承**     | 支持多继承（一个类可以实现多个接口）                | 不支持多继承（只能继承一个抽象类）             |
| **访问修饰符** | 接口中的方法默认是 `public`，不能指定其他访问修饰符 | 抽象类中的方法可以有不同的访问修饰符           |
| **实例化**     | 不能实例化接口                                      | 不能实例化抽象类                               |
| **用途**       | 用于定义行为规范，适用于多个类共享的行为            | 用于定义通用的类，适用于有共性和基本实现的类   |







### 9. List和Set

**`List`**：`List` 是有序的集合，意味着它会保持元素插入的顺序。你可以通过索引访问其中的元素。

**`Set`**：`Set` 是无序的集合，不保证元素的顺序。【只能通过迭代器逐一遍历】







### 10. 为什么重写equals一定要重写hashcode

**没有重写前** `hashCode` 方法返回对象的哈希值，这个哈希值就是在堆中的地址。

**重写后** 我们会根据对象的字段来计算哈希值，这样相同内容的对象（即使是不同的实例）也能产生相同的哈希值。

【**HashSet**、**HashMap**等在内部使用的是哈希值来进行对象存储和查找】







### 11. ArrayList与数组的区别与联系

JDK中使用数组 实现 ArrayList， **数组定长**，

ArrayList 为**不定长**（可以动态扩容）







### 12. HashMap 和 HashTable的区别

Hashtable是**线程安全**的，HashMap**线程不安全**

Hashtable默认的**初始大小为11**，之后每次扩充，容量变为**原来的2n+1**。

HashMap默认的**初始化大小为16**。之后每次扩充，容量变为**原来的2倍**









### 13. ArrayList和LinkedList的区别

**实现：**

ArrayList 基于`动态数组`，连续的内存访问，适合下标访问。`扩容机制`：因为数组长度固定，超出长度需要新建数组

LinkedList 基于`链表`，可以存在在分散的内存中，适合`插入和删除不适合查询`



**特点：**

ArrayList `元素访问的效率高` `插入和删除操作的效率低`

LinkedList 必须使用iterator不能使用for循环，`因为性能消耗极大`









### 14. 为什么ArrayList遍历快

ArrayList 使用 数组 作为元素的存储方式

对于数组而言，在内存中是**一段地址连续**的空间

可以使用**元素地址+偏移量**的方式直接定位目标元素的内存地址。





### 15. 静态变量和实例变量的区别

**静态变量**属于类，当类加载时被初始化， 并且只会实例化一次

**实例变量**属于对象，当对象被创建时初始化，每个对象拥有自己的实例变量。通过对象访问。





### 16. HashMap的put方法的具体流程

 **使用 `hashCode()` 判断**

当我们调用 `put()` 方法向 `HashMap` 中添加一个元素时，`HashMap` 会先使用该元素的 `hashCode()` 来计算其在哈希表中的存储位置。



**哈希值相同的情况下**

如果计算出的哈希值已经存在，`HashMap` 会检查该位置是否已经存有元素。如果没有元素，直接存入该位置。如果有元素，那么接下来会使用 **`equals()`** 方法进一步比较键是否相等。

- 如果 `equals()` 返回 `true`，那么说明两个对象是相等的，此时会更新旧的值

- 如果 `equals()` 返回 `false`，则表示这个新的键与该位置上的现有键不同，`HashMap` 会采用 **链表**（或红黑树，取决于实现细节）来处理 **哈希冲突**。这就是哈希冲突的解决方法。



**哈希冲突的处理**

**链表**：如果同一个桶中有多个元素，`HashMap` 使用链表来存储这些元素。每个元素都是一个键值对对象，它们通过链表连接起来。

**红黑树（JDK 8 及以上版本）**：当同一个桶中元素数量较多（通常是超过 8 个）时，`HashMap` 会将链表转化为红黑树，以提高查找效率。





### 17. 介绍下多线程

用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。

多线程：指的是这个程序（一个进程）运行时产生了不止一个线程





### 18. 连接池概念

一次性申请多个连接对象，缓存在池中，每次需要使用连接对象时直接从池中获取， 节省了频繁向数据库申请连接的时间。

常用连接池： **dbcp** / **c3p0** / **druid**





### 19. 哈希码相同equals一定相同吗

哈希码相同并不意味着 `equals()` 必须返回 `true`，但如果两个对象的 `equals()` 方法返回 `true`，那么它们的 `hashCode()` 必须相同。【哈希会导致哈希冲突，也就是多个字符用相同哈希值，equals比较的是内存中的数据必然相同】





### 20. ACID是什么

ACID 是数据库事务的四大基本特性，指：

- **原子性（Atomicity）**：事务中的所有操作要么全部成功，要么全部失败，不能只执行部分操作。
- **一致性（Consistency）**：事务的执行会使数据库从一个一致性状态转变到另一个一致性状态。事务执行前后，数据库的完整性约束（如外键约束）必须保持有效。
- **隔离性（Isolation）**：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。事务的隔离级别可以通过设置来控制。
- **持久性（Durability）**：一旦事务提交，其对数据库的修改将永久保存，即使系统发生崩溃，数据也不会丢失。







### 21. java类加载器有哪些

Java 中的类加载器主要有三种标准加载器：**根类加载器**、**扩展类加载器**和**系统类加载器**。你也可以通过继承 `ClassLoader` 类，创建自定义类加载器以满足特定需求。







### 22. java异常体系

Java 中的所有异常都来自于顶级父类 **Throwable**

Throwable两个子类 **Error**、 **Exception**

Error会导致程序结束、Exception不会







### 23. 线程的生命周期及状态

**生命周期**

**创建**、**就绪**、**运行**、**阻塞** 和 **终止**



**线程的状态**

**新建**：线程对象被创建，但尚未启动。

**就绪**：线程被启动并等待操作系统分配 CPU 时间片。

**运行**：线程正在运行，执行任务。

**阻塞**：线程因等待资源或条件被暂停执行。

**等待**：线程处于等待状态，等待其他线程的通知。

**超时等待**：线程在超时时间到达前进入等待状态。

**终止**：线程执行完毕或被异常终止。







### 24. 值传递和引用传递有什么区别

**值传递**：将一个变量作为参数传递给方法，传递的是该变量的值，在方法内部修改这个副本不会影响原始变量。

**引用传递**：常常是指传递的是引用（内存地址）







### 25. 说说cas

**CAS** 是一种常用的无锁并发控制技术，它通过比较并交换值来实现原子操作，能够高效地处理并发更新。





### 26. 数据结构

**数组（Array）**

- **简介**：数组是一种线性数据结构，其中的元素按顺序排列，每个元素都有一个索引，允许通过索引直接访问元素。数组的大小在创建时是固定的。
- 

**栈（Stack）**

- **简介**：栈是一种后进先出（LIFO）的数据结构。元素的添加和删除只能在栈顶进行。栈有两个主要操作：`push`（入栈）和 `pop`（出栈）。
- 

**队列（Queue）**

- **简介**：队列是一种先进先出（FIFO）的数据结构。元素的插入在队尾进行，删除操作在队头进行。



**链表（Linked List）**

- **简介**：链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。与数组不同，链表的元素在内存中不需要连续存储。



**树（Tree）**

- **简介**：树是一种层次型数据结构，由节点和边组成，其中一个节点被称为根节点，其它节点通过边连接。树具有递归结构，每个节点可以有多个子节点。



**图（Graph）**

- **简介**：图是一种由节点（顶点）和边组成的数据结构，节点之间通过边进行连接。图可以是有向的，也可以是无向的。图也可以是加权的，每条边都有一个权重。



**堆（Heap）**

- **简介**：堆是一种特殊的完全二叉树，通常用于实现优先队列。堆有两种常见形式：最大堆和最小堆。在最大堆中，父节点的值总是大于或等于子节点的值；而在最小堆中，父节点的值总是小于或等于子节点的值。



**散列表（Hash Table）**

- **简介**：散列表是一种通过哈希函数将键映射到对应值的数据结构，具有快速的查找、插入和删除操作。





### 27. 如何实现数组和List之间的转换

集合.toArray()方法:   List 转为数组

Arrays.asList()方法:  数组转为List







### 28. ArrayList 自动扩容机制

**默认容量为 10**，第一次扩容时从 10 增加到 15。

**每次扩容为原来的 1.5 倍**，但扩容后的容量不足以容纳新元素时会直接扩容到所需容量。

`当容量不足时，会创建一个更大的数组，将旧数组中的元素复制到新的数组中。`





### 29. hashMap 自动扩容机制

**初始容量**：`HashMap` 的默认初始容量为 **16**。

**加载因子**：默认加载因子是 **0.75**，表示当表中元素数量达到容量的 75% 时，会触发扩容。

**扩容后的容量**：每次扩容时，`HashMap` 会将容量扩大为原来的 **2 倍**。







### 30. 聊一下ConcurrentHashMap









### 31. 导致并发程序出现问题的根本原因是什么

线程竞争

原子性问题

死锁

不正确的锁管理





### 32. 线程池创建方式

使用 `Executors` 工厂方法创建线程池  【以下都是方法】

1.1 `newFixedThreadPool(int nThreads)`

**功能**：创建一个固定大小的线程池，池中始终保持 `nThreads` 个工作线程。

**特点**：当线程池中的线程处于空闲状态时，它们会被复用。当任务队列满时，提交的任务会被放入队列中，直到有线程空闲。



1.2 `newCachedThreadPool()`

- **功能**：创建一个可缓存的线程池，池中的线程数会根据任务的需求进行调整，空闲线程会被回收。
- **特点**：当任务提交到线程池时，如果线程池中有空闲线程，则重用这些线程。如果没有可用线程，线程池会创建新线程来执行任务。空闲线程在60秒后会被回收。



1.3 `newSingle2ThreadExecutor()`

- **功能**：创建一个单线程的线程池，只有一个线程会被用来执行任务。此线程池会确保任务按顺序执行。
- **特点**：适用于顺序执行任务的场景，避免并发执行的问题。



2. 使用 `ThreadPoolExecutor` 直接创建线程池

`ThreadPoolExecutor` 是 `ExecutorService` 的实现类，提供了更细粒度的配置选项。通过直接构造 `ThreadPoolExecutor`，可以定制线程池的行为，例如核心池大小、最大池大小、线程空闲时间、任务队列和拒绝策略。









### 33. 如何确定核心线程数

**CPU 密集型任务**：cpu核心数就可以

**I/O 密集型任务**：可以比 CPU 核心数大得多，因为线程并不频繁占用 CPU







### 34. 工厂模式

| **特点**     | **简单工厂模式**                           | **工厂方法模式**               | **抽象工厂模式**                               |
| ------------ | ------------------------------------------ | ------------------------------ | ---------------------------------------------- |
| **创建方式** | 通过一个工厂类创建所有对象                 | 每个产品有一个对应的工厂类     | 为每个产品族提供创建接口                       |
| **产品个数** | 通常只创建一个产品类型                     | 创建一个类型的产品             | 创建一组相关的产品                             |
| **适用场景** | 对象创建简单，产品种类较少                 | 产品较多，且每种产品有独立工厂 | 需要创建多个相关产品，且这些产品有相互依赖关系 |
| **灵活性**   | 不太灵活，一旦需要新增产品，工厂类需要修改 | 灵活，每个产品有独立的工厂类   | 高度灵活，适合创建多个相关产品                 |
| **复杂度**   | 简单，但不适应复杂产品                     | 中等，适应不同产品             | 较复杂，适合处理多个产品族的情况               |











### 35.上传数据的安全性你们怎么控制

**使用加密技术保护数据传输**

通过使用 HTTPS



**身份认证与授权**

确保只有经过授权的用户能够进行数据上传。常见的认证方式有用户名/密码认证、OAuth、JWT等。




















#### 1. 高性能sql编写/ SQL语句如何调优

1. 查询SQL尽量不要使用select *，而是select具体字段
2. 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1 （如果查询字段上有唯一索引，可以不加limit 1）
3. 尽量避免在where子句中使用or来连接条件(用or可能会使索引失效，从而全表扫描)
4. 优化limit分页
5. like语句: 把%放前面，并不走索引,% 放关键字后面，还是会走索引的
6. 使用where条件限定要查询的数据，避免返回多余的行
7. 避免在索引列上使用mysql的内置函数
8. 避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫
9. Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小
10. 避免在 where 子句中使用!=或<>操作符
11. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则
12. 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描
13. 如果插入数据过多，考虑批量插入
14. 适当的时候，使用覆盖索引
15. 使用explain 分析你SQL的计划

 

#### 2. 数据库的死锁问题

一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。



#### 3. 索引建立准则

1. 选择唯一性索引
2. 为经常需要排序、分组和联合操作的字段建立索引
3. 为常作为查询条件的字段建立索引
4. 限制索引的数目
5. 尽量使用数据量少的索引
6. 尽量使用前缀来索引
7. 删除不再使用或者很少使用的索引
8. 最左前缀匹配原则，非常重要的原则。
9. =和in可以乱序。
10. 尽量选择区分度高的列作为索引。
11. 索引列不能参与计算，保持列“干净”。
12. 尽量的扩展索引，不要新建索引。 
13. 当单个索引字段查询数据很多，区分度都不是很大时，则需要考虑建立联合索引来提高查询效率















#### 4. 左链接，右连接，全连接，内连接的区别

inner join: 两张表中都满足连接条件的部分数据

left join ： inner join + 左表多出的数据（表部分补NULL）

right join: inner join + 右表多出的数据（左表部分补NULL）

full join: 笛卡尔积





#### 5. mysql数据库里的对象

触发器（Trigger）、表（Table）、视图（View）、存储过程（StoredProcedure）、索引（Index）、缺省值（Default）、图表（Diagram）、用户（User）、规则（Rule）等





#### 6. mysql引擎有哪些？有什么区别

MyISAM，innoDB，MEMORY，ARCHIVE

InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。

MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率

MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果

如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archiv

 

 

#### 7. 数据库索引有哪些

普通索引，唯一索引， 主键索引， 组合索引







#### 10. DDL与DML区别

数据操作语言 (DML) 和 数据定义语言 (DDL)

DML:

*SELECT* - 从数据库表中获取数据

*UPDATE* - 更新数据库表中的数据

*DELETE* - 从数据库表中删除数据

*INSERT INTO* - 向数据库表中插入数据

DDL:

CREATE DATABASE - 创建新数据库

ALTER DATABASE - 修改数据库

CREATE TABLE - 创建新表

ALTER TABLE - 变更（改变）数据库表

DROP TABLE - 删除表

CREATE INDEX - 创建索引（搜索键）

DROP INDEX - 删除索引

1.DML操作是需要手动控制事务的开启、提交(commit)和回滚的。

2.DDL操作是隐性提交的，不能rollback！





#### 11. 为什么mysql里面加了索引就会变快

很多人会说索引就相当于一本书的目录，通过目录来找书中的某一页，确实是很快的，如果没有目录，就需要一页一页的去翻书了，大大降低了效率。这个比喻其实还挺恰当的，也是一个很经典的索引比喻了。

 

在 InnoDB 中，每个索引其实都是一颗 B+ 树，主键索引称作聚簇索引，其他非主键索引称作二级索引，每个表中每一行的记录值都完整的保存在主键索引的叶子节点上，二级索引的叶子节点保存的是主键的值。

 







#### 13. 一个sql语句查询时间很长，你要怎么优化

(1)  in 和 not in 要慎用，否则会导致全表扫描

(2)  查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）

(3)  涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合

(4)  如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度

(5)  针对数量大的表进行历史表分离（如交易流水表）

(6)  数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步

(7)  explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等

(8)  查看mysql执行日志，看看是否有其他方面的问题

(9)  对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引





#### 14. 事务四个特性（ACID）

原子性、一致性、隔离性、持久性



#### 15. 事务的隔离级别

Read Uncommitted（读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

Read Committed（读取提交内容）

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。

这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

Repeatable Read（可重读）

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。

简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

Serializable（可串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。





#### 17. sql执行很慢如何分析

查看执行计划Explain 

```sql
EXPLAIN SELECT * FROM your_table ;
```



通过key和key_len字段检查是否命中了索引（索引是否失效）

通过type字段查看sql有没有进一步的优化空间









#### 18. **Undo Log**

**作用**：

- 用于回滚事务（ROLLBACK）。

**原理**：

- 当对数据进行修改时，会记录一条日志，保存数据的**“旧值”**（即修改前的状态）。如果事务需要回滚，则通过 `undo log` 将数据恢复到原始状态。

**典型场景**：

- 事务中途失败或用户执行 `ROLLBACK`。











#### 19. Redo Log

**作用**：

- 用于恢复数据（REPAIR）。

**原理**：

- 当对数据进行修改时，会记录一条日志，保存数据的**“新值”**或更改操作的描述。当数据库崩溃后，通过 `redo log` 恢复提交成功但未持久化到磁盘的数据。

**典型场景**：

- 数据库崩溃重启时，通过 `redo log` 重做操作以确保提交的事务不会丢失。









#### 20. 解释一下mvcc(事务隔离性是如何保证的)

MVCC 多版本并发控制

它能够有效地保证事务的隔离性，避免脏读、重复读问题。

每个事务都有自己的数据快照，确保事务在执行期间只能看到自己独立的视图，而无法看到其他事务未提交的数据。











#### 21. MySQL 主从同步

MySQL主从复制的核心就是二进制日志binlog(**DDL(数据定义语言)**语句和 **DML(数据操纵语言)**语句)



主库在事务提交的时候，会把数据变更记录在二进制文件Binlog中。

从库读取主库的二进制日志文件Binlog，写入从库中Relay Log

从库执行日志中的事件，改变自己的数据





#### 22. 分库分表